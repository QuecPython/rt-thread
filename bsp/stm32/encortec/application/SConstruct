import os
import sys
import rtconfig
import shutil
import glob
from rtconfig import TARGET_NAME
from rtconfig import POST_ACTION
from rtconfig import SDK_ROOT
from rtconfig import RTT_ROOT
from rtconfig import BUILD_DIR
from rtconfig import BUILD_OBJS_DIR

TARGET = f'{TARGET_NAME}.{rtconfig.TARGET_EXT}'

DefaultEnvironment(tools=[])
env = Environment(tools = ['mingw'],
    AS = rtconfig.AS, ASFLAGS = rtconfig.AFLAGS,
    CC = rtconfig.CC, CFLAGS = rtconfig.CFLAGS,
    AR = rtconfig.AR, ARFLAGS = '-rc',
    CXX = rtconfig.CXX, CXXFLAGS = rtconfig.CXXFLAGS,
    LINK = rtconfig.LINK, LINKFLAGS = rtconfig.LFLAGS)
env.PrependENVPath('PATH', rtconfig.EXEC_PATH)

# Add include directories to the search path
CPPPATH = [
    os.path.join(SDK_ROOT, 'common'),
    SDK_ROOT,
    os.path.join(RTT_ROOT, 'include'),
    os.path.join(RTT_ROOT, 'components', 'finsh')]
env.Append(CPPPATH=CPPPATH)

# Get all .c files in the application directory
# app_c_files = glob.glob(os.path.join('main', '*.c'))
app_c_files = Split('''
main/main.c
main/rt_api.c
'''
)

# Build objects for your application's C files with output in the build directory
app_objs = [env.Object(os.path.join(BUILD_OBJS_DIR, os.path.splitext(c)[0]) + '.o', c) for c in app_c_files]

# Link the objects into an executable or library
elf_file = env.Program(TARGET, app_objs)

# Generate .bin file from the .elf file
bin_file = env.Command(f'{TARGET_NAME}.bin',
                       elf_file,
                       action=POST_ACTION)

# Default command
Default(elf_file, bin_file)

# Check if we are in clean mode
if GetOption('clean'):
    # Clean action to remove the entire build directory
    def clean_build_dir(target, source, env):
        if os.path.exists(BUILD_DIR):
            shutil.rmtree(BUILD_DIR)

    # Add the clean action to SCons
    env.AddMethod(clean_build_dir, 'CleanBuildDir')

    # Call the clean action when cleaning
    env.CleanBuildDir([], BUILD_DIR)
