import os
import sys
import rtconfig
import shutil
import glob
from rtconfig import TARGET_NAME
from rtconfig import POST_ACTION
from rtconfig import SDK_ROOT
from rtconfig import RTT_ROOT
from rtconfig import BUILD_DIR
from rtconfig import BUILD_OBJS_DIR

TARGET = f'{TARGET_NAME}.{rtconfig.TARGET_EXT}'

DefaultEnvironment(tools=[])
env = Environment(tools = ['mingw'],
    AS = rtconfig.AS, ASFLAGS = rtconfig.AFLAGS,
    CC = rtconfig.CC, CFLAGS = rtconfig.CFLAGS,
    AR = rtconfig.AR, ARFLAGS = '-rc',
    CXX = rtconfig.CXX, CXXFLAGS = rtconfig.CXXFLAGS,
    LINK = rtconfig.LINK, LINKFLAGS = rtconfig.LFLAGS)
env.PrependENVPath('PATH', rtconfig.EXEC_PATH)

# Add include directories to the search path
CPPPATH = [
    os.path.join(SDK_ROOT, 'common'),
    SDK_ROOT,
    os.path.join(RTT_ROOT, 'include'),
    os.path.join(RTT_ROOT, 'components', 'finsh'),
    os.path.join(RTT_ROOT, 'components/drivers/include'),
    os.path.join(RTT_ROOT, 'components/net/at/include'),
    os.path.join(SDK_ROOT, 'application', 'rt_api'),
    os.path.join(SDK_ROOT, 'application', 'logging'),
]

driver_list = os.listdir(os.path.join(SDK_ROOT, 'application/board/driver'))
driver_cpppath = [os.path.join(SDK_ROOT, 'application/board/driver', i) for i in driver_list if os.path.isdir(os.path.join(SDK_ROOT, 'application/board/driver', i))]
CPPPATH.extend(driver_cpppath)

env.Append(CPPPATH=CPPPATH)

# Get all .c files in the application directory
# app_c_files = glob.glob(os.path.join('main', '*.c'))
app_c_files = Split('''
main/main.c
rt_api/rt_api.c
logging/logging.c
'''
)

driver_c_files = [os.path.join('board/driver', i, "%s.c" % i) for i in driver_list if os.path.isdir(os.path.join(SDK_ROOT, 'application/board/driver', i))]

app_c_files.extend(driver_c_files)

# Build objects for your application's C files with output in the build directory
app_objs = [env.Object(os.path.join(BUILD_OBJS_DIR, os.path.splitext(c)[0]) + '.o', c) for c in app_c_files]

# Link the objects into an executable or library
elf_file = env.Program(TARGET, app_objs)

# Generate .bin file from the .elf file
bin_file = env.Command(f'{TARGET_NAME}.bin',
                       elf_file,
                       action=POST_ACTION)

# Default command
Default(elf_file, bin_file)

# Check if we are in clean mode
if GetOption('clean'):
    # Clean action to remove the entire build directory
    def clean_build_dir(target, source, env):
        if os.path.exists(BUILD_DIR):
            shutil.rmtree(BUILD_DIR)

    # Add the clean action to SCons
    env.AddMethod(clean_build_dir, 'CleanBuildDir')

    # Call the clean action when cleaning
    env.CleanBuildDir([], BUILD_DIR)
